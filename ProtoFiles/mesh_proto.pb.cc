// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesh_proto.proto

#include "mesh_proto.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR mesh_proto_mssg::mesh_proto_mssg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.meshname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vertices_)*/nullptr
  , /*decltype(_impl_.normals_)*/nullptr
  , /*decltype(_impl_.texcoords_)*/nullptr
  , /*decltype(_impl_.indices_)*/nullptr
  , /*decltype(_impl_.weights_)*/nullptr
  , /*decltype(_impl_.joints_)*/nullptr
  , /*decltype(_impl_.invbind_)*/nullptr
  , /*decltype(_impl_.bounding_sphere_)*/nullptr
  , /*decltype(_impl_.basecolor_)*/nullptr
  , /*decltype(_impl_.rendermode_)*/0
  , /*decltype(_impl_.hashid_)*/0u
  , /*decltype(_impl_.nummeshes_)*/0u
  , /*decltype(_impl_.tricount_)*/0u
  , /*decltype(_impl_.vertcount_)*/0u
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct mesh_proto_mssgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR mesh_proto_mssgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~mesh_proto_mssgDefaultTypeInternal() {}
  union {
    mesh_proto_mssg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 mesh_proto_mssgDefaultTypeInternal _mesh_proto_mssg_default_instance_;
bool mesh_proto_mssg_RENDER_MODE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> mesh_proto_mssg_RENDER_MODE_strings[7] = {};

static const char mesh_proto_mssg_RENDER_MODE_names[] =
  "LINE"
  "LINE_LOOP"
  "LINE_STRIP"
  "POINTS"
  "TRIANGLES"
  "TRIANGLE_FAN"
  "TRIANGLE_STRIP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry mesh_proto_mssg_RENDER_MODE_entries[] = {
  { {mesh_proto_mssg_RENDER_MODE_names + 0, 4}, 1 },
  { {mesh_proto_mssg_RENDER_MODE_names + 4, 9}, 2 },
  { {mesh_proto_mssg_RENDER_MODE_names + 13, 10}, 3 },
  { {mesh_proto_mssg_RENDER_MODE_names + 23, 6}, 0 },
  { {mesh_proto_mssg_RENDER_MODE_names + 29, 9}, 4 },
  { {mesh_proto_mssg_RENDER_MODE_names + 38, 12}, 6 },
  { {mesh_proto_mssg_RENDER_MODE_names + 50, 14}, 5 },
};

static const int mesh_proto_mssg_RENDER_MODE_entries_by_number[] = {
  3, // 0 -> POINTS
  0, // 1 -> LINE
  1, // 2 -> LINE_LOOP
  2, // 3 -> LINE_STRIP
  4, // 4 -> TRIANGLES
  6, // 5 -> TRIANGLE_STRIP
  5, // 6 -> TRIANGLE_FAN
};

const std::string& mesh_proto_mssg_RENDER_MODE_Name(
    mesh_proto_mssg_RENDER_MODE value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          mesh_proto_mssg_RENDER_MODE_entries,
          mesh_proto_mssg_RENDER_MODE_entries_by_number,
          7, mesh_proto_mssg_RENDER_MODE_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      mesh_proto_mssg_RENDER_MODE_entries,
      mesh_proto_mssg_RENDER_MODE_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     mesh_proto_mssg_RENDER_MODE_strings[idx].get();
}
bool mesh_proto_mssg_RENDER_MODE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, mesh_proto_mssg_RENDER_MODE* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      mesh_proto_mssg_RENDER_MODE_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<mesh_proto_mssg_RENDER_MODE>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::POINTS;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::LINE;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::LINE_LOOP;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::LINE_STRIP;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::TRIANGLES;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::TRIANGLE_STRIP;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::TRIANGLE_FAN;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::RENDER_MODE_MIN;
constexpr mesh_proto_mssg_RENDER_MODE mesh_proto_mssg::RENDER_MODE_MAX;
constexpr int mesh_proto_mssg::RENDER_MODE_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class mesh_proto_mssg::_Internal {
 public:
  static const ::vbo_proto_mssg& vertices(const mesh_proto_mssg* msg);
  static const ::vbo_proto_mssg& normals(const mesh_proto_mssg* msg);
  static const ::vbo_proto_mssg& texcoords(const mesh_proto_mssg* msg);
  static const ::vbo_proto_mssg& indices(const mesh_proto_mssg* msg);
  static const ::vbo_proto_mssg& weights(const mesh_proto_mssg* msg);
  static const ::vbo_proto_mssg& joints(const mesh_proto_mssg* msg);
  static const ::vbo_proto_mssg& invbind(const mesh_proto_mssg* msg);
  static const ::vec3_proto_mssg& bounding_sphere(const mesh_proto_mssg* msg);
  static const ::vec4_proto_mssg& basecolor(const mesh_proto_mssg* msg);
};

const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::vertices(const mesh_proto_mssg* msg) {
  return *msg->_impl_.vertices_;
}
const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::normals(const mesh_proto_mssg* msg) {
  return *msg->_impl_.normals_;
}
const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::texcoords(const mesh_proto_mssg* msg) {
  return *msg->_impl_.texcoords_;
}
const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::indices(const mesh_proto_mssg* msg) {
  return *msg->_impl_.indices_;
}
const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::weights(const mesh_proto_mssg* msg) {
  return *msg->_impl_.weights_;
}
const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::joints(const mesh_proto_mssg* msg) {
  return *msg->_impl_.joints_;
}
const ::vbo_proto_mssg&
mesh_proto_mssg::_Internal::invbind(const mesh_proto_mssg* msg) {
  return *msg->_impl_.invbind_;
}
const ::vec3_proto_mssg&
mesh_proto_mssg::_Internal::bounding_sphere(const mesh_proto_mssg* msg) {
  return *msg->_impl_.bounding_sphere_;
}
const ::vec4_proto_mssg&
mesh_proto_mssg::_Internal::basecolor(const mesh_proto_mssg* msg) {
  return *msg->_impl_.basecolor_;
}
void mesh_proto_mssg::clear_vertices() {
  if (GetArenaForAllocation() == nullptr && _impl_.vertices_ != nullptr) {
    delete _impl_.vertices_;
  }
  _impl_.vertices_ = nullptr;
}
void mesh_proto_mssg::clear_normals() {
  if (GetArenaForAllocation() == nullptr && _impl_.normals_ != nullptr) {
    delete _impl_.normals_;
  }
  _impl_.normals_ = nullptr;
}
void mesh_proto_mssg::clear_texcoords() {
  if (GetArenaForAllocation() == nullptr && _impl_.texcoords_ != nullptr) {
    delete _impl_.texcoords_;
  }
  _impl_.texcoords_ = nullptr;
}
void mesh_proto_mssg::clear_indices() {
  if (GetArenaForAllocation() == nullptr && _impl_.indices_ != nullptr) {
    delete _impl_.indices_;
  }
  _impl_.indices_ = nullptr;
}
void mesh_proto_mssg::clear_weights() {
  if (GetArenaForAllocation() == nullptr && _impl_.weights_ != nullptr) {
    delete _impl_.weights_;
  }
  _impl_.weights_ = nullptr;
}
void mesh_proto_mssg::clear_joints() {
  if (GetArenaForAllocation() == nullptr && _impl_.joints_ != nullptr) {
    delete _impl_.joints_;
  }
  _impl_.joints_ = nullptr;
}
void mesh_proto_mssg::clear_invbind() {
  if (GetArenaForAllocation() == nullptr && _impl_.invbind_ != nullptr) {
    delete _impl_.invbind_;
  }
  _impl_.invbind_ = nullptr;
}
void mesh_proto_mssg::clear_bounding_sphere() {
  if (GetArenaForAllocation() == nullptr && _impl_.bounding_sphere_ != nullptr) {
    delete _impl_.bounding_sphere_;
  }
  _impl_.bounding_sphere_ = nullptr;
}
void mesh_proto_mssg::clear_basecolor() {
  if (GetArenaForAllocation() == nullptr && _impl_.basecolor_ != nullptr) {
    delete _impl_.basecolor_;
  }
  _impl_.basecolor_ = nullptr;
}
mesh_proto_mssg::mesh_proto_mssg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:mesh_proto_mssg)
}
mesh_proto_mssg::mesh_proto_mssg(const mesh_proto_mssg& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  mesh_proto_mssg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.meshname_){}
    , decltype(_impl_.vertices_){nullptr}
    , decltype(_impl_.normals_){nullptr}
    , decltype(_impl_.texcoords_){nullptr}
    , decltype(_impl_.indices_){nullptr}
    , decltype(_impl_.weights_){nullptr}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.invbind_){nullptr}
    , decltype(_impl_.bounding_sphere_){nullptr}
    , decltype(_impl_.basecolor_){nullptr}
    , decltype(_impl_.rendermode_){}
    , decltype(_impl_.hashid_){}
    , decltype(_impl_.nummeshes_){}
    , decltype(_impl_.tricount_){}
    , decltype(_impl_.vertcount_){}
    , decltype(_impl_.radius_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.meshname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meshname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_meshname().empty()) {
    _this->_impl_.meshname_.Set(from._internal_meshname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_vertices()) {
    _this->_impl_.vertices_ = new ::vbo_proto_mssg(*from._impl_.vertices_);
  }
  if (from._internal_has_normals()) {
    _this->_impl_.normals_ = new ::vbo_proto_mssg(*from._impl_.normals_);
  }
  if (from._internal_has_texcoords()) {
    _this->_impl_.texcoords_ = new ::vbo_proto_mssg(*from._impl_.texcoords_);
  }
  if (from._internal_has_indices()) {
    _this->_impl_.indices_ = new ::vbo_proto_mssg(*from._impl_.indices_);
  }
  if (from._internal_has_weights()) {
    _this->_impl_.weights_ = new ::vbo_proto_mssg(*from._impl_.weights_);
  }
  if (from._internal_has_joints()) {
    _this->_impl_.joints_ = new ::vbo_proto_mssg(*from._impl_.joints_);
  }
  if (from._internal_has_invbind()) {
    _this->_impl_.invbind_ = new ::vbo_proto_mssg(*from._impl_.invbind_);
  }
  if (from._internal_has_bounding_sphere()) {
    _this->_impl_.bounding_sphere_ = new ::vec3_proto_mssg(*from._impl_.bounding_sphere_);
  }
  if (from._internal_has_basecolor()) {
    _this->_impl_.basecolor_ = new ::vec4_proto_mssg(*from._impl_.basecolor_);
  }
  ::memcpy(&_impl_.rendermode_, &from._impl_.rendermode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.radius_) -
    reinterpret_cast<char*>(&_impl_.rendermode_)) + sizeof(_impl_.radius_));
  // @@protoc_insertion_point(copy_constructor:mesh_proto_mssg)
}

inline void mesh_proto_mssg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.meshname_){}
    , decltype(_impl_.vertices_){nullptr}
    , decltype(_impl_.normals_){nullptr}
    , decltype(_impl_.texcoords_){nullptr}
    , decltype(_impl_.indices_){nullptr}
    , decltype(_impl_.weights_){nullptr}
    , decltype(_impl_.joints_){nullptr}
    , decltype(_impl_.invbind_){nullptr}
    , decltype(_impl_.bounding_sphere_){nullptr}
    , decltype(_impl_.basecolor_){nullptr}
    , decltype(_impl_.rendermode_){0}
    , decltype(_impl_.hashid_){0u}
    , decltype(_impl_.nummeshes_){0u}
    , decltype(_impl_.tricount_){0u}
    , decltype(_impl_.vertcount_){0u}
    , decltype(_impl_.radius_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.meshname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meshname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

mesh_proto_mssg::~mesh_proto_mssg() {
  // @@protoc_insertion_point(destructor:mesh_proto_mssg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void mesh_proto_mssg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.meshname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.vertices_;
  if (this != internal_default_instance()) delete _impl_.normals_;
  if (this != internal_default_instance()) delete _impl_.texcoords_;
  if (this != internal_default_instance()) delete _impl_.indices_;
  if (this != internal_default_instance()) delete _impl_.weights_;
  if (this != internal_default_instance()) delete _impl_.joints_;
  if (this != internal_default_instance()) delete _impl_.invbind_;
  if (this != internal_default_instance()) delete _impl_.bounding_sphere_;
  if (this != internal_default_instance()) delete _impl_.basecolor_;
}

void mesh_proto_mssg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void mesh_proto_mssg::Clear() {
// @@protoc_insertion_point(message_clear_start:mesh_proto_mssg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.meshname_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.vertices_ != nullptr) {
    delete _impl_.vertices_;
  }
  _impl_.vertices_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.normals_ != nullptr) {
    delete _impl_.normals_;
  }
  _impl_.normals_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.texcoords_ != nullptr) {
    delete _impl_.texcoords_;
  }
  _impl_.texcoords_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.indices_ != nullptr) {
    delete _impl_.indices_;
  }
  _impl_.indices_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.weights_ != nullptr) {
    delete _impl_.weights_;
  }
  _impl_.weights_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.joints_ != nullptr) {
    delete _impl_.joints_;
  }
  _impl_.joints_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.invbind_ != nullptr) {
    delete _impl_.invbind_;
  }
  _impl_.invbind_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.bounding_sphere_ != nullptr) {
    delete _impl_.bounding_sphere_;
  }
  _impl_.bounding_sphere_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.basecolor_ != nullptr) {
    delete _impl_.basecolor_;
  }
  _impl_.basecolor_ = nullptr;
  ::memset(&_impl_.rendermode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.radius_) -
      reinterpret_cast<char*>(&_impl_.rendermode_)) + sizeof(_impl_.radius_));
  _internal_metadata_.Clear<std::string>();
}

const char* mesh_proto_mssg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes meshName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_meshname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .mesh_proto_mssg.RENDER_MODE renderMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_rendermode(static_cast<::mesh_proto_mssg_RENDER_MODE>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 hashid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.hashid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 numMeshes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.nummeshes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 triCount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.tricount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 vertCount = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.vertcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg vertices = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_vertices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg normals = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_normals(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg texCoords = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_texcoords(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg indices = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg weights = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_weights(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg joints = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_joints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vbo_proto_mssg invBind = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_invbind(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vec3_proto_mssg bounding_sphere = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bounding_sphere(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float radius = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .vec4_proto_mssg baseColor = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_basecolor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* mesh_proto_mssg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesh_proto_mssg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes meshName = 1;
  if (!this->_internal_meshname().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_meshname(), target);
  }

  // .mesh_proto_mssg.RENDER_MODE renderMode = 2;
  if (this->_internal_rendermode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_rendermode(), target);
  }

  // uint32 hashid = 3;
  if (this->_internal_hashid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hashid(), target);
  }

  // uint32 numMeshes = 4;
  if (this->_internal_nummeshes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_nummeshes(), target);
  }

  // uint32 triCount = 5;
  if (this->_internal_tricount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_tricount(), target);
  }

  // uint32 vertCount = 6;
  if (this->_internal_vertcount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_vertcount(), target);
  }

  // .vbo_proto_mssg vertices = 7;
  if (this->_internal_has_vertices()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::vertices(this),
        _Internal::vertices(this).GetCachedSize(), target, stream);
  }

  // .vbo_proto_mssg normals = 8;
  if (this->_internal_has_normals()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::normals(this),
        _Internal::normals(this).GetCachedSize(), target, stream);
  }

  // .vbo_proto_mssg texCoords = 9;
  if (this->_internal_has_texcoords()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::texcoords(this),
        _Internal::texcoords(this).GetCachedSize(), target, stream);
  }

  // .vbo_proto_mssg indices = 10;
  if (this->_internal_has_indices()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::indices(this),
        _Internal::indices(this).GetCachedSize(), target, stream);
  }

  // .vbo_proto_mssg weights = 11;
  if (this->_internal_has_weights()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::weights(this),
        _Internal::weights(this).GetCachedSize(), target, stream);
  }

  // .vbo_proto_mssg joints = 12;
  if (this->_internal_has_joints()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::joints(this),
        _Internal::joints(this).GetCachedSize(), target, stream);
  }

  // .vbo_proto_mssg invBind = 13;
  if (this->_internal_has_invbind()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::invbind(this),
        _Internal::invbind(this).GetCachedSize(), target, stream);
  }

  // .vec3_proto_mssg bounding_sphere = 14;
  if (this->_internal_has_bounding_sphere()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::bounding_sphere(this),
        _Internal::bounding_sphere(this).GetCachedSize(), target, stream);
  }

  // float radius = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_radius(), target);
  }

  // .vec4_proto_mssg baseColor = 16;
  if (this->_internal_has_basecolor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::basecolor(this),
        _Internal::basecolor(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesh_proto_mssg)
  return target;
}

size_t mesh_proto_mssg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mesh_proto_mssg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes meshName = 1;
  if (!this->_internal_meshname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_meshname());
  }

  // .vbo_proto_mssg vertices = 7;
  if (this->_internal_has_vertices()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vertices_);
  }

  // .vbo_proto_mssg normals = 8;
  if (this->_internal_has_normals()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.normals_);
  }

  // .vbo_proto_mssg texCoords = 9;
  if (this->_internal_has_texcoords()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.texcoords_);
  }

  // .vbo_proto_mssg indices = 10;
  if (this->_internal_has_indices()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.indices_);
  }

  // .vbo_proto_mssg weights = 11;
  if (this->_internal_has_weights()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.weights_);
  }

  // .vbo_proto_mssg joints = 12;
  if (this->_internal_has_joints()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.joints_);
  }

  // .vbo_proto_mssg invBind = 13;
  if (this->_internal_has_invbind()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.invbind_);
  }

  // .vec3_proto_mssg bounding_sphere = 14;
  if (this->_internal_has_bounding_sphere()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bounding_sphere_);
  }

  // .vec4_proto_mssg baseColor = 16;
  if (this->_internal_has_basecolor()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.basecolor_);
  }

  // .mesh_proto_mssg.RENDER_MODE renderMode = 2;
  if (this->_internal_rendermode() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rendermode());
  }

  // uint32 hashid = 3;
  if (this->_internal_hashid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hashid());
  }

  // uint32 numMeshes = 4;
  if (this->_internal_nummeshes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nummeshes());
  }

  // uint32 triCount = 5;
  if (this->_internal_tricount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tricount());
  }

  // uint32 vertCount = 6;
  if (this->_internal_vertcount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vertcount());
  }

  // float radius = 15;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void mesh_proto_mssg::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const mesh_proto_mssg*>(
      &from));
}

void mesh_proto_mssg::MergeFrom(const mesh_proto_mssg& from) {
  mesh_proto_mssg* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:mesh_proto_mssg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_meshname().empty()) {
    _this->_internal_set_meshname(from._internal_meshname());
  }
  if (from._internal_has_vertices()) {
    _this->_internal_mutable_vertices()->::vbo_proto_mssg::MergeFrom(
        from._internal_vertices());
  }
  if (from._internal_has_normals()) {
    _this->_internal_mutable_normals()->::vbo_proto_mssg::MergeFrom(
        from._internal_normals());
  }
  if (from._internal_has_texcoords()) {
    _this->_internal_mutable_texcoords()->::vbo_proto_mssg::MergeFrom(
        from._internal_texcoords());
  }
  if (from._internal_has_indices()) {
    _this->_internal_mutable_indices()->::vbo_proto_mssg::MergeFrom(
        from._internal_indices());
  }
  if (from._internal_has_weights()) {
    _this->_internal_mutable_weights()->::vbo_proto_mssg::MergeFrom(
        from._internal_weights());
  }
  if (from._internal_has_joints()) {
    _this->_internal_mutable_joints()->::vbo_proto_mssg::MergeFrom(
        from._internal_joints());
  }
  if (from._internal_has_invbind()) {
    _this->_internal_mutable_invbind()->::vbo_proto_mssg::MergeFrom(
        from._internal_invbind());
  }
  if (from._internal_has_bounding_sphere()) {
    _this->_internal_mutable_bounding_sphere()->::vec3_proto_mssg::MergeFrom(
        from._internal_bounding_sphere());
  }
  if (from._internal_has_basecolor()) {
    _this->_internal_mutable_basecolor()->::vec4_proto_mssg::MergeFrom(
        from._internal_basecolor());
  }
  if (from._internal_rendermode() != 0) {
    _this->_internal_set_rendermode(from._internal_rendermode());
  }
  if (from._internal_hashid() != 0) {
    _this->_internal_set_hashid(from._internal_hashid());
  }
  if (from._internal_nummeshes() != 0) {
    _this->_internal_set_nummeshes(from._internal_nummeshes());
  }
  if (from._internal_tricount() != 0) {
    _this->_internal_set_tricount(from._internal_tricount());
  }
  if (from._internal_vertcount() != 0) {
    _this->_internal_set_vertcount(from._internal_vertcount());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void mesh_proto_mssg::CopyFrom(const mesh_proto_mssg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesh_proto_mssg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mesh_proto_mssg::IsInitialized() const {
  return true;
}

void mesh_proto_mssg::InternalSwap(mesh_proto_mssg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meshname_, lhs_arena,
      &other->_impl_.meshname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(mesh_proto_mssg, _impl_.radius_)
      + sizeof(mesh_proto_mssg::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(mesh_proto_mssg, _impl_.vertices_)>(
          reinterpret_cast<char*>(&_impl_.vertices_),
          reinterpret_cast<char*>(&other->_impl_.vertices_));
}

std::string mesh_proto_mssg::GetTypeName() const {
  return "mesh_proto_mssg";
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mesh_proto_mssg*
Arena::CreateMaybeMessage< ::mesh_proto_mssg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mesh_proto_mssg >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
